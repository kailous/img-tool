#!/bin/bash

# 获取当前目录并存储在变量中
current_directory=$(cd "$(dirname "$0")" && pwd)
# 配置文件路径
config_file="$current_directory/config.ini"
# 程序依赖文件夹
app_files="$current_directory/Contents"
# 图片压缩器
tinypng="$app_files/tinypng"
# webp转换器
cwebp="$app_files/cwebp"
# 图片文件夹
img_files="$current_directory/img"
# 输出文件夹
output_files="$current_directory/output"
# webp 文件夹
webp="$output_files/webp"

# 清除终端显示
clear

# 欢迎使用
echo "欢迎使用图片压缩工具, 免费压缩次数为500次/月。"
echo "待压缩的图片请放入 img 文件夹"


# 创建输出和webp文件夹
mkdir -p "$output_files" "$webp"

# 输出当前目录下的img文件夹中不同格式的图片文件的数量
echo "待压缩图片文件数量："
echo "------------------------"
for ext in jpg jpeg png gif; do
  count=$(find "$img_files" -maxdepth 1 -type f -iname "*.$ext" | wc -l)
  echo "$ext:   $count 张"
done
echo "------------------------"

# 读取INI配置文件
read_ini() {
    section=$1
    key=$2
    pattern="^\\[$section\\]$"
    value=""

    while IFS='=' read -r conf_key conf_value; do
        if [[ $conf_key =~ $pattern ]]; then
            reading_section=true
        elif [[ $conf_key =~ ^\[.*\]$ ]]; then
            reading_section=false
        elif [ "$reading_section" = true ] && [ "$conf_key" = "$key" ]; then
            value=$conf_value
            break
        fi
    done < "$config_file"

    echo "$value"
}

# 读取所有图片类型
read_types() {
    awk -F'[][]' '/^\[.*\]$/ {print $2}' "$config_file"
}

# 显示所有图片类型供用户选择
echo "请选择压缩类型："
types=$(read_types)
select_option=1
for type in $types; do
    echo "$select_option. $type"
    select_option=$((select_option + 1))
done

read -n1 -p "请输入您的选择: " compress_type
echo
type_selected=$(echo $types | cut -d ' ' -f$compress_type)

# 压缩图片函数
compress_image() {
    local label=$1
    local width=$2
    local height=$3
    if [ -z "$width" ] || [ -z "$height" ]; then
        echo "错误：缺少必要的宽度或高度参数。"
        return 1
    fi
    "$tinypng" "$img_files" --width "$width" --height "$height"
    find "$img_files" -type f \( -name "裁剪-*.jpg" -o -name "裁剪-*.png" \) -exec sh -c 'file={}; mv "$file" "$2/'"$label"'$(basename "$file")"' _ {} "$output_files" \;
}

# 根据选择读取配置并压缩图片
echo "选中的类型: $type_selected"
width=$(read_ini "$type_selected" "width")
height=$(read_ini "$type_selected" "height")

compress_image "$type_selected" "$width" "$height"
img_size=$(read_ini "$type_selected" "size")
# 提示开始转换webp格式
convert_to_webp() {
  echo "是否继续转换为webp (Y/N): "
  read -n1 webpyes
  echo
  case $webpyes in
    Y|y)  
      echo "开始转换"
      export DYLD_FALLBACK_LIBRARY_PATH="$app_files/libs"
      find "$output_files" -type f \( -iname "*裁剪-*.jpg" -o -iname "*裁剪-*.jpeg" -o -iname "*裁剪-*.png" -o -iname "*裁剪-*.gif" \) | while read -r file; do
          "$cwebp" -lossless -m 6 "$file" -o "$webp/$(basename "$file" .jpg).webp"
      done
      echo "压缩完成"
      echo "------------------------"
      echo "按任意键打开压缩后的图片文件夹"
      read -r
      open "$output_files"
      ;;
    N|n)
      echo "感谢使用"
      exit 0
      ;;
    *)
      ;;
  esac
}

# 处理图片大小超标的情况
process_images() {
    local img_size=$1
    find "$output_files" -type f \( -name "*裁剪-*.jpg" -o -name "*裁剪-*.png" \) | while read file; do
        file_size=$(du -k "$file" | cut -f1)
        if [ "$file_size" -gt "$img_size" ]; then
            echo "$file 超出限制，可以尝试转换成webp。"
            convert_to_webp
        else
            echo "$file 合格"
            echo "没有需要转换的图片"
            exit 0
        fi
    done
}

# 根据压缩的类型做不同的判断
if [ "$label" -eq 1 ]; then
    process_images "$main_img_size"
elif [ "$label" -eq 2 ]; then
    process_images "$cover_img_size"
else
    echo "没有需要转换的图片"
    exit 0
fi

# 脚本结束
echo "处理完成。"

